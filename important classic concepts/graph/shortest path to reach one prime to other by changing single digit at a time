#include<bits/stdc++.h>
using namespace std;

vector<int> g[100000];
vector<int> prime;
int dist[100000],visited[100000];
void bfs(int node)
{
    queue<int> q;
    q.push(node);
    visited[node]=1;
	dist[node]=0;
    while(!q.empty())
    {
        int fro=q.front();
        q.pop();
        for(int i:g[fro])
        {
            if(visited[i]==0)
            {
                q.push(i);
                visited[i]=1;
				dist[i]=dist[fro]+1;
            }
        }
    }
    return;
}
bool isprime(int n)
{

    for(int i=2;i*i<=n;i++)
    {

        if(n%i==0) return false;
    }
    return true;
}
bool isvalid(int a,int b)
{
    int cnt=0;
    while(a>0)
    {

        if(a%10!=b%10) cnt++;
        a/=10;
        b/=10;
    }
    if(cnt==1) return true;
    else return false;
}
void buildgraph()
{

    for(int i=1000;i<=9999;i++)
        if(isprime(i))
        prime.push_back(i);

    for(int i=0;i<prime.size();i++)
    {
        for(int j=i+1;j<prime.size();j++)
        {

            if(isvalid(prime[i],prime[j]))
                g[prime[i]].push_back(prime[j]),g[prime[j]].push_back(prime[i]);
        }
    }

}
int main() {
	int t;
	cin>>t;
	buildgraph();
	while(t--)
	{
		int v,e;
		cin >> v >> e;

		for(int i=1000;i<=9999;i++)
		{
			dist[i]=-1;
			visited[i]=0;
		}
		bfs(v);
		if(dist[e]==-1) cout<<"Impossible"<<endl;
        else cout<<dist[e]<<endl;
	}

  return 0;
}
